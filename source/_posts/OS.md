---
layout: OS
date: 2019-05-18 15:31:31
tags:
---

# 操作系统
## 指令的执行
### 处理器 - 存储器：数据可以从处理器传输到存储器或者从存储器传输到处理器
### 处理器 - I/O设备：通过处理器和I/O模块之间的s数据传送，数据可以输出到外部设备，或者从外部设备输入数据
### 数据处理：处理器可以执行很多和数据相关的算数操作或者逻辑操作
### 控制：某些指令可以改变执行的顺序
---
## 存储器的层次结构
### 计算器的设计目标可以归纳为三个问题：多大容量？多快速度？多贵价格？
## 价格、容量、访问时间之间的关系
1. 存取时间越快，每“位”的价格越高
2. 容量越大，每“位”的价格越低
3. 容量越大，存取速度越慢
## 高速缓冲存储器
### 高速缓冲存储器是存在于主存和CPU之间的一级存储器，容量小但比主存快的多，接近CPU的速度
### 高速缓冲存储器最重要的技术是它的命中率
---
## 中断
### 程序中断：在某些条件下由指令执行的结果产生，如算数溢出、除数为零、试图执行一条非法的机器指令以及访问用户不允许的存储位置
### 时钟中断：有处理器内部的计时器产生允许操作系统以一定规律执行函数
### I/O中断：由输入输出控制器产生，用于发信号通知一个操作的正常完成或各种错误条件
### 硬件失效中断：诸如掉电或存储器的奇偶校验错之类的故障产生
---
## 对称多处理器：
### 1. 具有两个或者两个以上的处理器
### 2.这些处理器共享I/O设备并通过总线的方式进行连接
### 3.所有的处理器可以执行相同的功能（所以说是对称的）
### 4.整个系统由一个统一的操作系统进行控制
## 多核算计：
### 1.是指两个或者多个处理器组装在同一硅片上，又叫单芯片多处理器
---
## 计算机系统:
### 分为**软件**和**硬件** 软件分为应用软件和系统软件 系统软件包括**操作系统**和光盘刻录工具/汇编程序/编译程序/数据库管理系统。
---
## **操作系统的定位：**
## 操作系统是管理计算机硬件和软件资源的程序，同时也是计算机系统的核心基石，操作系统身负诸如管理与配置内存、决定系统资源的优先级、控制输入输出设备、操作网络与管理文件系统等基本事务。
### 操作系统是紧靠在硬件的一层原件层 工作在操作系统上的有各种各样的系统工具。
---
## **操作系统的设计目标：**
**方便**性、**有效**性、**可扩充**性、**开放**性。
- **方便**性：提供用户接口，使用计算机系统更方便。
- **有效**性：通过有效管理和分配软硬件资源及合理组织计算机工作流程来改善资源利用率、提高吞吐量。
- **可扩充**性：适应计算机硬件和体系结构的迅猛发展及其所对应的更高的功能和性能要求。
- **开放**性：适应不同的厂家与不同类型的计算机及其设备的网络化集成和协同工作，实现应用程序的可移植性和互操作性。
---
## **用户与计算机硬件系统之间的接口：**
## 命令接口、系统调用接口。
- **命令接口**（操作系统外壳）：1.面向一般用户  2.命令行/菜单行/命令脚本式/图形用户接口  3.提供了计算机的便利方式。
- **系统调用方式**（操作系统内核）：1.面向编程开发人员  2.形式上类似于过程调用，编制程序中使用。  3.程序访问操作系统服务的基本机制。
---
## **操作系统的管理对象：**
## 处理器、存储器、外围设备以及信息（数据和软件）。
---
## **操作系统的管理内容：**
## 1.资源的分配、回收和访问操作  
## 2.记录资源的当前状态（数据和使用情况）、相应的管理策略（共享、保护及用户权限）。
## **操作系统的定义：操作系统是基本的系统软件，是一组有效管理和控制计算机硬件资源和软件资源、合理地对各类作业进行调动以组织和控制系统 工作流程，并方便使用计算机的程序的集合**

---
## windows的内核态组件包括以下类型：
### **执行体：**包括操作系统的核心服务
---
## 程序：
### 程序是一组指令的有序集合，本身没有任何运行的含义，它只是一个静态的实体。
## 进程：
### 进程是一个动态的实体，它有自己的生命周期，因创建而产生，因调动而运行，因等待资源而被处于等待状态，因完成任务而被撤销反映了一个程序在一定的数据集上运行的全部动态过程
## 进程和线程的区别在于：
## 一个程序至少有一个进程,一个进程至少有一个线程
## 多线程：
### 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行
## 操作系统的引导程序（Boot Loader）
---
# 操作系统的内核：
### 内核是操作系统的核心。它负责管理系统的进程、内存、和设备驱动程序、文件和网络系统决定者系统的性能和稳定性
## 定位：
### 是操作系统最基本的部分
## 内核的分类：
## 单内核
### 是个很大的进程。它的内部又能够被分为若干模块（或是层次或其他）。但是在运行的时候，它是个单独的二进制大映象。其模块间的通讯是通过直接调用其他模块中的函数实现的，而不是消息传递
### 微内核
### 混合内核
### 外内核
## Linux的内核组件
### 信号：内核通过信号通知进程。例如信号通知进程的某些错误，比如说清零错误
### **系统调用：** 进程是通过系统调用来请求系统服务的
### **进程和调度器** 创建 管理 调动进程
### **虚拟内存** 为进程分配和管理虚拟内存
### **文件系统** 为文件目录提供一个全局分层次的命名空间
---
## 进程定义
### 1.一个真正执行的程序
### 2.一个在计算机上执行的程序实例
### 3.能分配给处理器并由处理器执行的实体
### 4.一组指令序列的执行、一个当前状态和相关的系统资源集
进程的两个基本元素是 **程序代码** 和 **代码相关联的数据集** 
## 进程唯一表征的元素
- 标识符：跟这个进程唯一相关的标识符，用来区别其他进程
- 状态：如果程序正在执行那么程序处于运行状态
- 优先级：相对于其他程序的优先级
- 程序计数器：程序中即将被执行的下一条指令的地址
- 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
- 上下文数据：进程执行时处理器寄存器中的数据
- I/O状态信息：包括显式的I/O请求，分配给进程的输入输出设备和被使用的文件列表等
- 记账信息：包括处理器的时间总和、使用的时钟总和、时间限制、记账号等。
---
## 线程
### 操作系统能够运算调度的最小单位，它被包含在进程中是进程的实际运作单位。
### 多线程：
### 多线程是指操作系统在单个进程内支持多个并发执行路径的能力，每个进程中只有一个线程执行的方法被称为单线程方法。
## 线程的功能特性：
### 派生：
### 当派生一个进程的时候，同时也为该进程派生出了一个线程。随后进程中的线程可能在同一个线程中派生另一个线程并为新线程提供指令指针和参数；新线程拥有自己的寄存器上下文和栈空间，并且被放在就绪队列中
### 阻塞：
### 当线程需要等待一个事件时它将被阻塞，此时处理器会执行另一个就绪线程
### 解除阻塞：
### 当阻塞线程的事件发生的时候，该线程被转到就绪队列中
### 结束：
### 当一个线程完成时，其寄存器上下文和栈都被释放。
## 线程同步
### 一个进程的所有线程共享同一个地址空间和诸如打开的文件之类的其他资源，一个线程对资源的修改会影响同一个进程中其他线程的环境
## 线程分类：
### 用户级线程
### 有关线程的所有工作都是由应用程序自己完成，内核意识不到线程的存在
### 内核级线程
### 有关线程的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码
### 粗粒度线程
### 粗粒度线程或者称为子系统，被分配到单独的处理器
### 细粒度线程
### 许多相似的任务被分布到多个处理器上，例如一个数组上进行迭代的循环可以被分割成一些小的循环小循环在多个独立线程上并行执行
## 线程状态
### 就绪态
就绪态线程可以被调度执行，内核分派器跟踪所有就绪线程，并按优先级顺序进行调度
### 备用态
备用态是已近被选择在一个特定的处理器上执行。该程序在这个状态等待直到处理器可用，如果这个线程的优先级足够高，正在处理器上的线程可能被这个备用线程抢占，否则，该备用线程会等到正在运行的线程被阻塞或者时间片结束
### 运行态
一旦内核分派器执行了线程切换备用线程将进入运行状态并开始执行，执行一直到该线程被抢占、用完时间片、被阻塞或者终止，在前两种情况下它将回到就绪态
### 等待态
当线程被一个时间阻塞，为了同步自愿等待，或者挂起时该线程进入等待状态当等待的条件满足时，如果所有的资源都可用的时候转到就绪态
### 过渡态
一个线程在等待后，如果准备好运行但是资源不可用的时候，进入该状态。例如一个线程的栈被换出内存。当该资源可用的时候线程进入就绪状态
### 终止态
一个线程可以被自己或者另一个线程终止，或者他的父进程被终止时被终止，一旦完成处理工作该线程从系统中移除
## 死锁和饥饿
### 死锁产生的条件：
- 互相排斥：一个线程永远占有共享资源
- 循环等待：进程a在等待进程b,进程b在等待进程c,进程c在等待进程a。
- 部分分配：进程a和进程b都需要访问一个文件，同时需要打印用到打印机，而进程a得到了文件资源，进程b得到了打印机资源，但是两个进程都得不到全部的资源
- 缺少优先权：一个进程获得了一个资源但是一直不进行释放该资源即使该资源处于阻塞状态
### 饥饿
当一组进程中的每个进程都在等待某个事件（所请求的资源被释放），而只有在这组进程中的其他阻塞进程才能触发该事件，而只有这组进程中的其他阻塞进程才能触发该事件，称这组进程发生死锁
### 死锁避免
如果一个进程的请求会导致死锁，则不启动此程序
如果一个进程增加的资源会导致死锁则不允许此分配
***
## 内存管理
### 内存管理的需求
- 重保护
- 保护
- 共享
- 逻辑组织
- 物理组织
### 重保护
在多到程序设计中，可用的内存空间被多道进程共享一道程序被换入到磁盘的时候，当下一次被换入得时候，如果必须放入到和被换出前的相同的区域，这将是一个限制，为了避免这种限制就要重定位到内存的不同区域当中去
### 保护
每一个进程都应该受到保护，以免被其他进程有意或者无意的干涉。因此该进程以外的其他进程不能未经授权地访问该进程的内存单元。
### 共享
任何保护的进程都应该具有一定的灵活性，允许多个进程访问内存中的一部分
### 逻辑组织
计算机系统的内存总是被组织成线性的地址空间，而且空间是由一系列字节或者字组成的
### 物理组织
计算机的存储器至少被组织成两级，称为内存和外存。内存提供快速的访问，但是成本也比较高，并且内存是易失的，不能永久保存。外存比内存慢但是便宜，通常是非易失的。大量的外存可以长期的存储程序的数据，而内存则用于保存当前使用的数据和程序
### 内存分区
内存管理的基本操作是由处理器把内存装入内存中执行

## **动态分区**

分区的长度和数目是可变的，系统会分配一块和它所需的容量完全相等的内存空间，动态分区在开始的时候是很好的，但是随着时间的推移内存空间会出现许多小的空洞而且会越来越多内存的利用率也会下降，克服碎片的方法是进行压缩操作系统不时的移动进程，使进程占用空间的连续

### **压缩**的缺点是非常耗费处理器的时间，压缩就要动态重定位的能力，把一个进程从一个地址转移到另一个地址
## **固定分区**

固定分区就是把内存的空间分成相等的块，如果一个进程的大小和区的大小刚好相等或者更小这样的程序就会被执行，如果所有的分区都满了，并且没有进程就绪状态，操作系统会换出一个进程的所有分区，并装上另一个进程
固定分区的缺点：
1. 程序太大的话就不能放在一个分区程序员使用覆盖技术先把一部分需要的放入内存中当需要的模块不在的时候用户程序必须把这个模块装入这个分区，覆盖掉该分区的任何数据和程序
2. 固定分区的内存利用率会非常的低，任何程序都会占据一个完整的区，多余的这些空间被称为内部碎片
---
 ## **放置算法：**
 因为内存的压缩非常耗费时间所以操作系统就把需要不同内存的进程放到原来执行完的空间来填补这些碎片

**最佳适配**

查找内存中的碎片找到最接近和相等的碎片分配给该进程

**首次适配**

在内存的开始进行查找碎片只要出现碎片空间和进程空间相同就进行分配

**下次适配**

结果通常是位于内存的末尾，这样就会导致内存末尾的空间被快速的分裂成小的碎片

**固定分区**和**动态分区**的都有不足，固定限制了活动进程的数目，如果进程的大小和分区的空间不匹配则内存的利用率是很低的动态分区比较复杂，并且引入了内存压缩的额外开销

## **分页**
---
### 大小相等的固定分区和大小可变的固定分区内存的利用率是非常低效的固定分区会产生内部碎片，动态分区会产生外部碎片，如果内存被划分成大小相同的块，并且大小相对较小，每一个进程也被分为大小相等的块，这些块就叫做页每个可用的页被称为页框，这样每个进程在内存中浪费的空间就是最后一页的的一小部分形成的内部碎片，没有任何外部碎片

如果没有足够的连续的页框来保存一个进程，操作系统也不会阻止内存的加载，可以用逻辑地址来解决这个问题，操作系统要为每一个进程维护一个页表，列表给出了进程的每一页对应的页框的位置，每一个逻辑地址包括页号何在该页的偏移量，在分页中逻辑地址到物理地址的转换仍由处理器的硬件完成

分页和固定分区不同：

分页类似于固定分区，不同之处在于分页采用的分区相当小，一个进程可以占用多个分区，并且分区不需要是连续的

分页地址转换的步骤：

逻辑地址和物理地址之间的转换首先要提取页号，以页号为索引可以简单的把页框号附加到页框号后面来构造物理地址

总结：

分页就是把内存分为许多大小相等的页，较小的进程需要较少的页，较大的进程需要较多的页，它的所有的页都被装在页框中，并且建立一个表
---

## **分段**
---
### 可以把进程和其相关的数据划分到几个段中，尽管段有最大长度限制，但是不要求所有程序的所有段都相等，和分页一样分段的逻辑地址也分为两部分段号和偏移量，分段类似于动态分区，与动态分区不同的是，在分段的方案中，一个进程可以占用多个分段，并且不是连续的，分段消除了内部碎片，但是产生了外部碎片，由于一个进程被分为多个块，因此碎片也会很小。

在简单的分段方案中，每个进程都有一个**段表**，内存也会维护一个进程中的空闲列表，每个段表项必须给出相应的段在内存中的起始地址，当进程进入运行状态的时候系统将会把地址装在寄存器当中。

分段地址转换的步骤

提取段号，以段号为索引，查找该进程段表中的该断的物理地址，偏移量和段长度进行比较，如果偏移量大于该段的长度，则地址无效

物理地址为该段的起始地址和改段的偏移量的总和
## **虚拟内存**
---
### 进程中的所有访问都是逻辑地址，这些地址在运行时动态的转换成物理地址，这就意味着一个进程被换入或者换出内存使得进程在执行的过程中的不同时刻占据内存的不同区域
一个进程可以划分成许多块，在执行的过程中不需要连续地址都在内存中，页表和段表的使用让进程运行的时候的地址转换成为了可能

**常驻集：**

有了页表和段表，在进程的执行过程中，该进程不需要所有的段或者页在内存中
假设需要把一个进程放入内存时，操作系统仅读取包含程序开始时的一个或者几个块，进程的执行中任何时候都在内存的部分称为进程的常驻集。

当执行的过程中只要所有的内存访问都是访问进程的常驻集中的单元，执行就可以顺利进行如果处理器要访问一个不在内存中的逻辑地址，则产生一个中断，说明产生了内存访问故障，操作系统把中断的进程置于阻塞状态。

为了能继续执行这个进程，操作系统必须把引发访问故障的逻辑地址的进程块读入内存，这时操作系统会产生一个磁盘的I/O请求，产生请求之后，在执行磁盘I/O期间，操作系统可以调用另一个进程的运行，一旦需要的块被读入内存，则产生一个I/O中断，控制交给操作系统，而操作系统把缺少该块的被阻塞的进程置为就绪状态

但是这样的方法效率很低，下面的方法可以提高系统的利用率
在内存中保留多个进程，因为对任何进程仅仅装入进程的某些块，因此就有足够的空间来放置的更多的进程，这样在进行读写的时候就能够处理其他的进程，从而提高处理器的利用

**实存储器**

由于一个进程只能在内存中执行，因此这个存储器称为实存储器

**虚存**

比内存更大的存储器称为虚拟内存，虚存支持更有效的多道程序设计

在虚拟内存中，在任何时刻任何一个进程只有一部分位于内存中，可以在内存中保留更多的进程，由于没有用到的块不需要换入换出内存，因而节省了时间，当操作系统读取一块的时候必须把另一块换出，如果一块正好在将要用到之前换出，操作系统就不得不很快的把它取回来

**系统抖动：**

系统抖动就是处理器的大部分时间都用于交换块，而不是执行指令，所以要避免过多的系统抖动发生

**局部性原理：**

局部性原理描述了一个进程中程序和数据的引用的集簇倾向，假设在一个很短的时间内需要进程的一部分块是合理的，同时还可以猜测将可能访问的块，从而避免系统抖动

---

### 段页式
在段页式系统中，用户地址被划分成许多段。每个段被依次划分成大小相同的页，页的长度等于内存中页框的大小。如果某一段的长度  小于一页，则该段只占据一页。逻辑地址依然是由段号和偏移量组成的；段偏移量可以看做是指定段中的一个页号和页偏移量
### 保护和共享
分段有助于实现保护与共享机制。由于每个段包括一个长度和一个基地址，因此程序不会轻易的访问超出该段的内存单元。为实现共享，一个段可以在多个进程中被引用。在分页系统中也可以得到同样的机制。但是此种情况下程序的页结构和数据对程序员是不可见的，使得共享和保护的要求难以说明。
## 调度
### 调度的类型
长程调度|决定加入执行的进程池中
--:|:--
中程调度|决定加入部分或全部在内存中的进程集合中
短程调度|决定哪一个可执行的进程将被处理器执行
I/O调度|决定哪一个进程的I/O请求将被可用的I/O设备处理
长程调度，它决定是否把进程添加到当前活跃的进程集合中。中程调度是交换的一部分，它决定是否把进程添加到那些至少部分在内存中并且可以被执行的进程集合中去。短程调度真正决定下一次执行哪一个就绪进程。

**长程调度：**

长程调度决定哪一个程序可以进入系统中处理，它控制着系统并发度。一旦允许进入，一个作业或者用户程序就成为了一个进程，并被添加到被短程调度使用的队列中等待调动

在批处理系统或者操作系统的批处理中，新提交的作业被发送到磁盘，并保存在一个批处理队列中。在长程调度程序运行的时候，从队列中创建相应的进程。

调动程序需要决定什么时候操作系统能够接纳一个或者多个进程；同时，调度程序必须决定哪个作业或者哪些作业，将会变成进程。

创建的进程越多，每个进程可以执行的时间所占百分比就越小。当一个作业被终止的时候，调度程序可以决定增加一个或者多个新作业。此外，如果处理器空闲的时间超过了一定的阈值，也会启用长程调度程序。

**短程调度**

考虑执行的频繁度，长程调度执行的频率相对较低，并且仅仅是粗略的决定是否接受新进程及接受哪一个。为进行交换决定，中程调度程序执行的稍微频繁了一些。短程调度程序，也叫分派程序，执行地最为频繁，并且精确地决定下一次执行哪一个进程。

**优先级的使用**

在许多系统中，每个进程都被指定一个优先级，调度程序总是选择优先级高的进程。

纯粹的优先级方案会产生一个问题，低优先级的进程可能会长期处于饥饿状态。如果一直有高优先级的就绪程序，就会发生这种情况。一个进程的优先级应该随着时间或执行历史而变化。

---
## **多处理器调度**
多处理器系统可以分为以下几类：
- 松耦合、分布式多处理器、集群：由一系列相对自制的系统组成，每一个处理器都有自己的内存和I/O通道。
- 专门功能的处理器：I/O处理器就是一个例子。在这种情况下有一个通用的主处理器，专用处理器受主处理器的控制，并给主处理器提供服务。
- 紧耦合多处理器：由一系类共享同一个内存并在操作系统的完全控制之下的处理器组成。
### **粒度**
一种描述多处理器把它结构放置在一个上下文环境中的较好的方法是，考虑进程之间的同步粒度，或者说同步频率。
我们可以根据粒度的不同来区分五类并行度。
粒度大小|说明|同步间隔(指令)
--:|:--:|:--
细|单指令流中固有的并行|<20
中等|在一个单独应用中的并行处理或多任务处理|20~200
粗|在多到程序中并发进程的多处理|200~2000
非常粗|在网络节点上进行分部处理，形成一个计算环境|2000~1M
无约束|多个无关的进程|不适用
**无约束并行性** 
对于无约束并行性没有显示的同步。每个进程都代表独立的应用或者作业。这类并行性的一个列子是分时系统。每个用户都执行一个特定的应用。多处理器和单道多处理器一样提供相同的服务。由于有多个处理器可以用，因此用户平均响应的时间非常短。

无约束并行有可能达到这样的性能，每个用户都如同在使用个人计算机或工作站。如果任何一个文件或信息被共享，则单个系统必须连接在一个有网络支持的分部系统中。

粗粒度和非常粗粒度并行性 粗粒度和非常粗的粒度并行，是指进程之间存在着同步，但是在一个非常粗的级别上。这种情况可以简单地处理一组运行在多道程序单处理器上的并发进程，在多处理器上对用户的软件进行很少的改动或者不进行改动就可以提供支持。

中等粒度并行性 应用程序可以通过进程中的一组线程被有效的实现，在这种情况下，必须由程序员指定应用程序潜在的并行性。为了达到中等粒度并行性的同步，在应用程序之间，需要更高程度的合作和交互。

尽管多道程序单处理器和多处理器都支持独立、非常粗和粗粒度的并行度，基本上不会对调度功能产生影响，但是在处理线程调度的时候，仍然需要重新分析调度。由于应用程序中各个线程间的交互非常频繁，导致系统对一个线程的调度决策会影响整个应用的性能。

细粒度的并行性 细粒度并行性代表着比线程中的并行更加复杂的使用情况。

**设计问题**

多处理器中的调度涉及三个相关联的问题：
- 把进程分配到处理器
- 在单个进程中使用多道程序设计
- 一个进程的实际分派

在讨论这三个问题的时候，必须牢记采用的方法通常取决于应用程序的粒度等级和可用处理器的数目

把进程分配到处理器 如果假设处理器的结构是统一的，即没有没有哪个处理器在访问内存和I/O设备的同时具有特别的物理优势，最简单的方法是把处理器当做一个资源池，并按照要求把资源分配到相应的处理器

如果一个程序从激活到完成，一直被分配给同一个处理器，那么就需要为每个处理器维护一个专门短程队列。这个方法的优势是调度的开销比较小，因为所有的进程，关于处理器的分配只进行一次。

静态分配的缺点是一个处理器可能处于空闲状态，这时它的列队为空，而另一个处理器却积压了很多工作。为了防止这种事情的发生，需要使用一个公共队列所有的进程进入到一个全局队列，然后调度到任何一个可用的处理器中。这样在一个进程的生命周期中，他可以在不同的时间在不同的处理器上执行。

**进程调度**

在大多数操作系统中，进程并不是被指定到专门的处理器的。不是所有的处理器只有一个队列，或者使用某种类型的优先级方案，而是有多条基于优先级的队列。

**线程调度**

线程执行的概念与进程中的定义是不同的。一个应用程序可以作为一组线程来实现，这些线程可以在同一个地址空间中协作和并发地执行。

在单处理中，线程可以做辅助构造程序，并通过处理过程中的重叠执行I/O。由于在进行线程切换时的系统开销远远小于进程切换的进程开销，因此可以用很小的代价来实现这个优点，在多处理器系统中，线程的全部能力得到了更好的展现。在多处理器环境中，线程可以用于开发应用程序中真正的并行性。如果一个应用程序的各个线程同时在独立的处理器中执行，性能就会显著提高。

在多处理器线程调度和处理器分配中各种方案，有四种比较突出的方法：

- 负载分配进程不是分配到一个特定的处理器的，系统维护一个就绪线程的全局队列，每个处理器只要空闲之后就从队列中选取一个线程。
- 调度组一组相关的进程基于一对一的原则，同时调度到一组处理器上运行。
- 专用处理器分配这种方法正好和负载分配相反，它是通过把线程指定到处理器来定义隐式的调度。每个进程在执行的过程中，被分配到一组处理器，处理器的数目与程序中线程的数目相等。当程序在终止的时候，处理器返回到总的处理器池中，可供另一个程序
- 动态调配在执行的过程中，进程中的线程数是可变的

**负载分配：**

负载分配是最简单的方法，也是可以从单个处理器环境中直接移动的方法。它的优点：
1. 负载均匀地分配在各个处理器上，确保当有工作要做的时候，没有处理器是空闲的。
2. 不需要集中地调度。当一个处理器可以用的时候，操作系统就会在该处理器上运行，以选择下一个线程

**三种不同的负载分配方案：**

**先来的先服务：**

当一个作业到达的时，它的所有线程都被连续的放置在共享队列的末尾，当一个处理器变得空闲的时候，它选择下一个就绪线程执行，直到完成或者被阻塞。

**最少线程数优先：**

共享就绪队列被组织成一个优先级队列，如果一个进程的未调度线程数最少，则指定最高的优先级，具有相同的优先级的队列按作业到达的顺序排队，被调度的线程直到完成或者被阻塞。

**可抢占的最少线程数优先：**

最高的优先级给予包含的未被调度的线程数目最小的作业。对于刚到达的作业，如果包含的线程数目少于正在被执行的作业，它将抢占属于这个被调度的作业的线程。

**负载分配的缺点：**

中心队列访问了必须互斥访问的存储器区域。因此如果许多处理器同时进行工作查找，这有可能成为瓶颈。当有很少的处理器的时候，不是什么问题。
被抢站的线程可能不在同一个处理器上恢复执行。
如果所有的线程被视为一个公共的线程池，则一个程序的所有线程不可能都同时获得对方处理器的访问，如果一个程序的线程之间需要高度的合作，所涉及的进程切换回严重影响性能。

**组调度：**

同时在一组处理器上调度一组进程的概念比线程的使用要早

**组调动的优点：**

1. 如果紧密相关的进程并行执行，同步的阻塞可能会减少，并且可能只需要很少的进程切换，性能会提高。
2. 调度开销的可能会减少，因为一个决策可以影响很多处理器和进程。

**专用处理器分配：**

在一个应用器执行期间，把一组处理器专门分配给这个应用程序。当一个程序被调用的时候，它的每个线程都被分配给处理器，这个处理器专门用于这个线程，直到应用程序结束

这个方法看上去很浪费处理器时间，如果应用程序的一个线程被阻塞，等待I/O或其他线程的同步，则该线程的的处理器一直处于空闲：处理器没有多道程序的设计。

在一个高度并行的系统中，有数十个或者数百个处理器，每个处理器只占处理器代价很小的一部分，处理器的利用率不再是衡量有效性和性能的一个要素。
在一个生命周期中避免进程切换会加快进程的速度。

**动态调度：**

某些程序可能提供了语言和系统工具，允许动态改变线程的数目，这样就使得操作系统调整负载情况来提高利用率。
## I/O管理和磁盘调度
I/O设备
计算机系统中参与I/O的外部设备大体上可以分为以下三个类别
- 人可读：适用于同计算机之间的交互，例如打印机和终端，后者包括了显示器和键盘，以及一些可能的设备，如鼠标等。
- 机器可读：适用于电子设备通信，例如磁盘驱动、USB秘钥、传感器、控制器和执行器。
- 通信：适用于远程设备通信，列如数字电路驱动器和调制解调器。

各个类别之间有很大的差别，甚至同一级别的不同设备之间也有相当大的差异，主要包括：
- 数据速率：数据传输速率可能会相差几个数量级。
- 应用：设备用途对操作系统及支撑设置中的软件和策略都有影响。例如储存文件的磁盘需要文件管理软件的支持；在虚拟存储系统中，用于页面备份的磁盘，其特性取决于虚拟存储硬件和软件是如何使用的。
- 控制的重复性：打印机需要一个相对简单的控制接口，而磁盘的控制接口要复杂的多。
- 传送单位：数据可以按照字节流或者字符流的形式传送，也可以按照更大的块来传送。
- 数据表示：不同的设备使用不同的数据编码方式，这些差别包括字符编码和奇偶校验约定。
- 错误条件：随着设备的不同，错误的性质、报告错误的方式、错误造成的后果及有效地相应范围，都有不同。

I/O功能的组织
执行I/O的三种技术
程序控制I/O:处理器代表一个进程给I/O模块发送的I/O命令；该进程进入忙等待，直到操作完成才可以继续执行。
中断驱动I/O：处理器代表进程向I/O模块发出一个I/O命令。有两种可能性：如果来自进程的I/O指令是非阻塞的那么处理器执行下一条指令则来自操作系统，它将当前的进程设置为阻塞状态并且调度其他的进程。
直接存储访问：一个DMA模块控制内存和I/O模块之间的数据交换。为传送一块数据，处理器给DMA模块发请求，只有当每个数据块传送结束之后，它才能中断。
DMA技术工作流程：当处理器想读一块数据的时，它通过DMA模块发送一下信息来给DMA模块发出一条指令。

- 请求读操作或者写操作的信号，通过在处理器和DMA模块之间使用读写控制线发送。
- 相关输入输出设备，通过数据线传送
- 从存储器中读或者往存储器中写的起始地址，在数据线上传送，并由DMA模块保存在其地址寄存器中。
- 读或写的字数，也通过数据线传送，并由DMA模块保存在其数据计数寄存器中。
操作系统设计问题：
设计目标
在设计I/O机制时，有两个重要的目标：效率和通用性。效率是最重要的。与内存和处理器比较，大多数I/O设备速度是非常低的。解决这一问题的方法是多道程序设计，多道程序设计允许在一个进程执行的同时其他一些进程在等待I/O操作。I/O设计的一个主要任务是提高I/O的效率。
通用性
人们希望能用一种统一的方式处理所有的设备。这意味着两个方面都要统一，一个试处理器看待I/O设备的方式，另一个是操作系统管理I/O设备和I/O操作方式。由于设备特性的多样性，在实际中很难真正实现通用性。目前所能做的就是用一种层次化的、模块化的方法设计I/O功能。
I/O功能的逻辑结构
分层的原理是，操作系统的功能可以根据其复杂性、特征和时间尺度和抽象层次分开。每一层都执行操作系统所需功能的一个相关子集，它依赖于更低一层所执行的更原始的功能，从而影藏这些细节功能的细节。同时，又给更高一层提供服务。
I/O缓冲
假设一个用户进程需要存磁盘中读入多个数据块，每次读一块，每块的长度为512个字节。这些数据将被读入用户进程中的一个区域，最简单的方法是对磁盘的执行单元执行一个I/O命令，并等待数据传送完成。这个等待可以是忙等待，也可以是进程被中断挂起。
单缓冲
操作系统提供最简单缓冲类型就是单缓冲。当用户进程I/O请求时，操作系统给该操作分配一个位于内存中系统部分的缓冲区。
单缓冲的方案描述：输入传送的数据被放到系统缓冲区中。当传送完成时，进程把该块移到用户空间。并立即请求另一块。这称2位预读，或者预先输入。这样做的原因是期望着个块最终会被使用。对于许多类型计算机来说，这个假设在大多数情况下是不合理的，因为数据是被顺序访问的。只有在处理队列的最后，才会读入一个不必要的块。
双缓冲
作为单缓冲的改进方案，可以给操作分配两个系统缓冲区，在一个进程往一个缓冲区中传送数据的同时，操作系统正在清空另一个缓冲区这种技术叫做双缓冲区，或缓冲交换
循环缓冲
双缓冲可以平滑I/O设备和数据之间的数据流。如果关注的焦点是某个特定的进程的性能，那么常常会希望相关的I/O操作能跟的上这个进程。如果该进程需要爆式的执行大量的I/O操作，仅仅有两个缓冲器不够。通常情况下会用多余两个缓冲区的方案来缓解不足。
当使用两个以上的缓冲区的时候，这组缓冲区自身被当做循环缓冲区，其中每个缓冲区是是循环缓冲的一个单元。
缓冲的作用：
缓冲是用来平滑I/O需求的一种技术，但是当进程的平均需求大于I/O设备的服务能力的时候，缓冲再也不会让I/O设备与这个进程一直并驾齐驱。即使有多个缓冲区，所有的缓冲区终将会被填满，进程在处理完一大块数据之后不得不等待。但是，在多道程序设计的时候，当存在多种I/O活动和多进程活动的时候，缓冲是提高操作系统和单进程性能的一种方法。
## **磁盘调度**
### **磁盘性能参数**
磁盘I/O的实际操作取决于计算机系统，操作系统以及I/O通道和磁盘控制器等硬件的特性。
当磁盘驱动工作器的时候，磁盘以一种恒定的速度旋转。为了读写，磁头必须位于指定的磁道和该磁道中指定的扇区的开始处。磁道的选择包括在活动头系统中移动磁头或者在固定头系统中电子选择一个磁头。在活动头系统中磁头定位磁道的时间称作寻道时间。在任何一种情况下，一旦选好磁道，磁盘控制器就开始等待，直到适当的扇区旋转到磁头的时候。磁头到达到达扇区开始的时间叫做旋转延迟。寻道时间和旋转延迟总和为存取时间，这是达到读或者写所需要的时间。一旦磁头定位完成磁头就通过下面的扇区开始执行读写操作，这正是操作数据传送部分。传输所需的时间是传输时间。
除了存取时间之外，一次磁盘I/O操作通常还会有一些排队延迟。当一个进程发出I/O请求时，必须在一个队列中等待该设备可用。在合适的时候，该设备分配给这个进程。如果该设备与其它磁盘驱动器共享一个I/O通道或一组I/O通道，还可能需要额外的时间等待，直到该通道可用。在这之后开始访问磁盘。
在一些高端服务系统中，使用了一种称为旋转定位感知的技术。具体的工作流程如下：
当发出一道寻址命令的时候，通道被释放以处理其他的I/O操作；当寻道完成的时候设备确定何时数据旋转到磁头下面；当该扇区接近磁头的时，这个设备试图重新建立和主机的通讯路径；如果控制单元正在处理另一个I/O，则重新连接尝试失败，设备必须转一周，再重新尝试连接。
寻道时间：
寻道时间是将磁头臂移到制定磁道所需时间。这个时间很难减少。寻道时间由两部分组成：最初启动时间，以及一旦访问臂到达一定的速度，横跨那些必须跨越的磁道所需的时间。
旋转延迟：
旋转延迟是将磁盘等待访问地址区域旋转到读写磁头可访问的位置所需要的时间。磁盘的旋转速度是将磁盘的等待访问地址区域旋转到读写磁头可访问的位置所需要的时间。
传输时间：
往磁盘传送或从磁盘传送的时间取决于磁盘的旋转速度。
磁盘调度策略：
先进先出：
最简单的调度是先进先出调度，它按顺序处理队列中的项目。
优先级：
这种方法并不会优化磁盘的利用率，但是可以满足操作系统的其他目标。通常较短的批作业和交互作业的优先级较高，而较长时间的长作业的优先级较低。这就使得大量的短作业能够迅速地通过系统，并且可以提供相对较好的交互相应时间。但是，作业可能不得不等待过长的时间。这种策略可能会导致部分用户采用对抗手段：把作业分成小块，以回应系统的这种策略。对于数据库系统，这类作业往往会导致性能较差。
最短服务时间优先：
最短服务时间优先策略使磁头臂从当前位置移动最小的磁盘I/O请求。最短服务时间优先总是选择导致最小寻道时间的请求。当然，总是选择最小寻道时间并不能保证平均寻道时间最小，由于磁头臂可以沿两个方向移动，因此可以使用一种随机选择算法机解决距离相等的情况。
[Boot Loader](https://baike.baidu.com/item/Boot%20Loader/10958293?fr=aladdin)