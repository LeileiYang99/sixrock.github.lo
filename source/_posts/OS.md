---
layout: OS
date: 2019-05-18 15:31:31
tags:
---

# 操作系统
## 指令的执行
### 处理器 - 存储器：数据可以从处理器传输到存储器或者从存储器传输到处理器
### 处理器 - I/O设备：通过处理器和I/O模块之间的s数据传送，数据可以输出到外部设备，或者从外部设备输入数据
### 数据处理：处理器可以执行很多和数据相关的算数操作或者逻辑操作
### 控制：某些指令可以改变执行的顺序
---
## 存储器的层次结构
### 计算器的设计目标可以归纳为三个问题：多大容量？多快速度？多贵价格？
## 价格、容量、访问时间之间的关系
1. 存取时间越快，每“位”的价格越高
2. 容量越大，每“位”的价格越低
3. 容量越大，存取速度越慢
## 高速缓冲存储器
### 高速缓冲存储器是存在于主存和CPU之间的一级存储器，容量小但比主存快的多，接近CPU的速度
### 高速缓冲存储器最重要的技术是它的命中率
---
## 中断
### 程序中断：在某些条件下由指令执行的结果产生，如算数溢出、除数为零、试图执行一条非法的机器指令以及访问用户不允许的存储位置
### 时钟中断：有处理器内部的计时器产生允许操作系统以一定规律执行函数
### I/O中断：由输入输出控制器产生，用于发信号通知一个操作的正常完成或各种错误条件
### 硬件失效中断：诸如掉电或存储器的奇偶校验错之类的故障产生
---
## 对称多处理器：
### 1. 具有两个或者两个以上的处理器
### 2.这些处理器共享I/O设备并通过总线的方式进行连接
### 3.所有的处理器可以执行相同的功能（所以说是对称的）
### 4.整个系统由一个统一的操作系统进行控制
## 多核算计：
### 1.是指两个或者多个处理器组装在同一硅片上，又叫单芯片多处理器
---
## 计算机系统:
### 分为**软件**和**硬件** 软件分为应用软件和系统软件 系统软件包括**操作系统**和光盘刻录工具/汇编程序/编译程序/数据库管理系统。
---
## **操作系统的定位：**
## 操作系统是管理计算机硬件和软件资源的程序，同时也是计算机系统的核心基石，操作系统身负诸如管理与配置内存、决定系统资源的优先级、控制输入输出设备、操作网络与管理文件系统等基本事务。
### 操作系统是紧靠在硬件的一层原件层 工作在操作系统上的有各种各样的系统工具。
---
## **操作系统的设计目标：**
**方便**性、**有效**性、**可扩充**性、**开放**性。
- **方便**性：提供用户接口，使用计算机系统更方便。
- **有效**性：通过有效管理和分配软硬件资源及合理组织计算机工作流程来改善资源利用率、提高吞吐量。
- **可扩充**性：适应计算机硬件和体系结构的迅猛发展及其所对应的更高的功能和性能要求。
- **开放**性：适应不同的厂家与不同类型的计算机及其设备的网络化集成和协同工作，实现应用程序的可移植性和互操作性。
---
## **用户与计算机硬件系统之间的接口：**
## 命令接口、系统调用接口。
- **命令接口**（操作系统外壳）：1.面向一般用户  2.命令行/菜单行/命令脚本式/图形用户接口  3.提供了计算机的便利方式。
- **系统调用方式**（操作系统内核）：1.面向编程开发人员  2.形式上类似于过程调用，编制程序中使用。  3.程序访问操作系统服务的基本机制。
---
## **操作系统的管理对象：**
## 处理器、存储器、外围设备以及信息（数据和软件）。
---
## **操作系统的管理内容：**
## 1.资源的分配、回收和访问操作  
## 2.记录资源的当前状态（数据和使用情况）、相应的管理策略（共享、保护及用户权限）。
## **操作系统的定义：操作系统是基本的系统软件，是一组有效管理和控制计算机硬件资源和软件资源、合理地对各类作业进行调动以组织和控制系统 工作流程，并方便使用计算机的程序的集合**

---
## windows的内核态组件包括以下类型：
### **执行体：**包括操作系统的核心服务
---
## 程序：
### 程序是一组指令的有序集合，本身没有任何运行的含义，它只是一个静态的实体。
## 进程：
### 进程是一个动态的实体，它有自己的生命周期，因创建而产生，因调动而运行，因等待资源而被处于等待状态，因完成任务而被撤销反映了一个程序在一定的数据集上运行的全部动态过程
## 进程和线程的区别在于：
## 一个程序至少有一个进程,一个进程至少有一个线程
## 多线程：
### 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行
## 操作系统的引导程序（Boot Loader）
---
# 操作系统的内核：
### 内核是操作系统的核心。它负责管理系统的进程、内存、和设备驱动程序、文件和网络系统决定者系统的性能和稳定性
## 定位：
### 是操作系统最基本的部分
## 内核的分类：
## 单内核
### 是个很大的进程。它的内部又能够被分为若干模块（或是层次或其他）。但是在运行的时候，它是个单独的二进制大映象。其模块间的通讯是通过直接调用其他模块中的函数实现的，而不是消息传递
### 微内核
### 混合内核
### 外内核
## Linux的内核组件
### 信号：内核通过信号通知进程。例如信号通知进程的某些错误，比如说清零错误
### **系统调用：** 进程是通过系统调用来请求系统服务的
### **进程和调度器** 创建 管理 调动进程
### **虚拟内存** 为进程分配和管理虚拟内存
### **文件系统** 为文件目录提供一个全局分层次的命名空间
---
## 进程定义
### 1.一个真正执行的程序
### 2.一个在计算机上执行的程序实例
### 3.能分配给处理器并由处理器执行的实体
### 4.一组指令序列的执行、一个当前状态和相关的系统资源集
进程的两个基本元素是 **程序代码** 和 **代码相关联的数据集** 
## 进程唯一表征的元素
- 标识符：跟这个进程唯一相关的标识符，用来区别其他进程
- 状态：如果程序正在执行那么程序处于运行状态
- 优先级：相对于其他程序的优先级
- 程序计数器：程序中即将被执行的下一条指令的地址
- 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
- 上下文数据：进程执行时处理器寄存器中的数据
- I/O状态信息：包括显式的I/O请求，分配给进程的输入输出设备和被使用的文件列表等
- 记账信息：包括处理器的时间总和、使用的时钟总和、时间限制、记账号等。
---
## 线程
### 操作系统能够运算调度的最小单位，它被包含在进程中是进程的实际运作单位。
### 多线程：
### 多线程是指操作系统在单个进程内支持多个并发执行路径的能力，每个进程中只有一个线程执行的方法被称为单线程方法。
## 线程的功能特性：
### 派生：
### 当派生一个进程的时候，同时也为该进程派生出了一个线程。随后进程中的线程可能在同一个线程中派生另一个线程并为新线程提供指令指针和参数；新线程拥有自己的寄存器上下文和栈空间，并且被放在就绪队列中
### 阻塞：
### 当线程需要等待一个事件时它将被阻塞，此时处理器会执行另一个就绪线程
### 解除阻塞：
### 当阻塞线程的事件发生的时候，该线程被转到就绪队列中
### 结束：
### 当一个线程完成时，其寄存器上下文和栈都被释放。
## 线程同步
### 一个进程的所有线程共享同一个地址空间和诸如打开的文件之类的其他资源，一个线程对资源的修改会影响同一个进程中其他线程的环境
## 线程分类：
### 用户级线程
### 有关线程的所有工作都是由应用程序自己完成，内核意识不到线程的存在
### 内核级线程
### 有关线程的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码
### 粗粒度线程
### 粗粒度线程或者称为子系统，被分配到单独的处理器
### 细粒度线程
### 许多相似的任务被分布到多个处理器上，例如一个数组上进行迭代的循环可以被分割成一些小的循环小循环在多个独立线程上并行执行
## 线程状态
### 就绪态
就绪态线程可以被调度执行，内核分派器跟踪所有就绪线程，并按优先级顺序进行调度
### 备用态
备用态是已近被选择在一个特定的处理器上执行。该程序在这个状态等待直到处理器可用，如果这个线程的优先级足够高，正在处理器上的线程可能被这个备用线程抢占，否则，该备用线程会等到正在运行的线程被阻塞或者时间片结束
### 运行态
一旦内核分派器执行了线程切换备用线程将进入运行状态并开始执行，执行一直到该线程被抢占、用完时间片、被阻塞或者终止，在前两种情况下它将回到就绪态
### 等待态
当线程被一个时间阻塞，为了同步自愿等待，或者挂起时该线程进入等待状态当等待的条件满足时，如果所有的资源都可用的时候转到就绪态
### 过渡态
一个线程在等待后，如果准备好运行但是资源不可用的时候，进入该状态。例如一个线程的栈被换出内存。当该资源可用的时候线程进入就绪状态
### 终止态
一个线程可以被自己或者另一个线程终止，或者他的父进程被终止时被终止，一旦完成处理工作该线程从系统中移除
## 死锁和饥饿
### 死锁产生的条件：
- 互相排斥：一个线程永远占有共享资源
- 循环等待：进程a在等待进程b,进程b在等待进程c,进程c在等待进程a。
- 部分分配：进程a和进程b都需要访问一个文件，同时需要打印用到打印机，而进程a得到了文件资源，进程b得到了打印机资源，但是两个进程都得不到全部的资源
- 缺少优先权：一个进程获得了一个资源但是一直不进行释放该资源即使该资源处于阻塞状态
### 饥饿
当一组进程中的每个进程都在等待某个事件（所请求的资源被释放），而只有在这组进程中的其他阻塞进程才能触发该事件，而只有这组进程中的其他阻塞进程才能触发该事件，称这组进程发生死锁
### 死锁避免
如果一个进程的请求会导致死锁，则不启动此程序
如果一个进程增加的资源会导致死锁则不允许此分配
***
## 内存管理
### 内存管理的需求
- 重保护
- 保护
- 共享
- 逻辑组织
- 物理组织
### 重保护
在多到程序设计中，可用的内存空间被多道进程共享一道程序被换入到磁盘的时候，当下一次被换入得时候，如果必须放入到和被换出前的相同的区域，这将是一个限制，为了避免这种限制就要重定位到内存的不同区域当中去
### 保护
每一个进程都应该受到保护，以免被其他进程有意或者无意的干涉。因此该进程以外的其他进程不能未经授权地访问该进程的内存单元。
### 共享
任何保护的进程都应该具有一定的灵活性，允许多个进程访问内存中的一部分
### 逻辑组织
计算机系统的内存总是被组织成线性的地址空间，而且空间是由一系列字节或者字组成的
### 物理组织
计算机的存储器至少被组织成两级，称为内存和外存。内存提供快速的访问，但是成本也比较高，并且内存是易失的，不能永久保存。外存比内存慢但是便宜，通常是非易失的。大量的外存可以长期的存储程序的数据，而内存则用于保存当前使用的数据和程序
### 内存分区
内存管理的基本操作是由处理器把内存装入内存中执行

## **动态分区**

分区的长度和数目是可变的，系统会分配一块和它所需的容量完全相等的内存空间，动态分区在开始的时候是很好的，但是随着时间的推移内存空间会出现许多小的空洞而且会越来越多内存的利用率也会下降，克服碎片的方法是进行压缩操作系统不时的移动进程，使进程占用空间的连续

### **压缩**的缺点是非常耗费处理器的时间，压缩就要动态重定位的能力，把一个进程从一个地址转移到另一个地址
## **固定分区**

固定分区就是把内存的空间分成相等的块，如果一个进程的大小和区的大小刚好相等或者更小这样的程序就会被执行，如果所有的分区都满了，并且没有进程就绪状态，操作系统会换出一个进程的所有分区，并装上另一个进程
固定分区的缺点：
1. 程序太大的话就不能放在一个分区程序员使用覆盖技术先把一部分需要的放入内存中当需要的模块不在的时候用户程序必须把这个模块装入这个分区，覆盖掉该分区的任何数据和程序
2. 固定分区的内存利用率会非常的低，任何程序都会占据一个完整的区，多余的这些空间被称为内部碎片
---
 ## **放置算法：**
 因为内存的压缩非常耗费时间所以操作系统就把需要不同内存的进程放到原来执行完的空间来填补这些碎片

**最佳适配**

查找内存中的碎片找到最接近和相等的碎片分配给该进程

**首次适配**

在内存的开始进行查找碎片只要出现碎片空间和进程空间相同就进行分配

**下次适配**

结果通常是位于内存的末尾，这样就会导致内存末尾的空间被快速的分裂成小的碎片

**固定分区**和**动态分区**的都有不足，固定限制了活动进程的数目，如果进程的大小和分区的空间不匹配则内存的利用率是很低的动态分区比较复杂，并且引入了内存压缩的额外开销

## **分页**
---
### 大小相等的固定分区和大小可变的固定分区内存的利用率是非常低效的固定分区会产生内部碎片，动态分区会产生外部碎片，如果内存被划分成大小相同的块，并且大小相对较小，每一个进程也被分为大小相等的块，这些块就叫做页每个可用的页被称为页框，这样每个进程在内存中浪费的空间就是最后一页的的一小部分形成的内部碎片，没有任何外部碎片

如果没有足够的连续的页框来保存一个进程，操作系统也不会阻止内存的加载，可以用逻辑地址来解决这个问题，操作系统要为每一个进程维护一个页表，列表给出了进程的每一页对应的页框的位置，每一个逻辑地址包括页号何在该页的偏移量，在分页中逻辑地址到物理地址的转换仍由处理器的硬件完成

分页和固定分区不同：

分页类似于固定分区，不同之处在于分页采用的分区相当小，一个进程可以占用多个分区，并且分区不需要是连续的

分页地址转换的步骤：

逻辑地址和物理地址之间的转换首先要提取页号，以页号为索引可以简单的把页框号附加到页框号后面来构造物理地址

总结：

分页就是把内存分为许多大小相等的页，较小的进程需要较少的页，较大的进程需要较多的页，它的所有的页都被装在页框中，并且建立一个表
---

## **分段**
---
### 可以把进程和其相关的数据划分到几个段中，尽管段有最大长度限制，但是不要求所有程序的所有段都相等，和分页一样分段的逻辑地址也分为两部分段号和偏移量，分段类似于动态分区，与动态分区不同的是，在分段的方案中，一个进程可以占用多个分段，并且不是连续的，分段消除了内部碎片，但是产生了外部碎片，由于一个进程被分为多个块，因此碎片也会很小。

在简单的分段方案中，每个进程都有一个**段表**，内存也会维护一个进程中的空闲列表，每个段表项必须给出相应的段在内存中的起始地址，当进程进入运行状态的时候系统将会把地址装在寄存器当中。

分段地址转换的步骤

提取段号，以段号为索引，查找该进程段表中的该断的物理地址，偏移量和段长度进行比较，如果偏移量大于该段的长度，则地址无效

物理地址为该段的起始地址和改段的偏移量的总和
## **虚拟内存**
---
### 进程中的所有访问都是逻辑地址，这些地址在运行时动态的转换成物理地址，这就意味着一个进程被换入或者换出内存使得进程在执行的过程中的不同时刻占据内存的不同区域
一个进程可以划分成许多块，在执行的过程中不需要连续地址都在内存中，页表和段表的使用让进程运行的时候的地址转换成为了可能

**常驻集：**

有了页表和段表，在进程的执行过程中，该进程不需要所有的段或者页在内存中
假设需要把一个进程放入内存时，操作系统仅读取包含程序开始时的一个或者几个块，进程的执行中任何时候都在内存的部分称为进程的常驻集。

当执行的过程中只要所有的内存访问都是访问进程的常驻集中的单元，执行就可以顺利进行如果处理器要访问一个不在内存中的逻辑地址，则产生一个中断，说明产生了内存访问故障，操作系统把中断的进程置于阻塞状态。

为了能继续执行这个进程，操作系统必须把引发访问故障的逻辑地址的进程块读入内存，这时操作系统会产生一个磁盘的I/O请求，产生请求之后，在执行磁盘I/O期间，操作系统可以调用另一个进程的运行，一旦需要的块被读入内存，则产生一个I/O中断，控制交给操作系统，而操作系统把缺少该块的被阻塞的进程置为就绪状态

但是这样的方法效率很低，下面的方法可以提高系统的利用率
在内存中保留多个进程，因为对任何进程仅仅装入进程的某些块，因此就有足够的空间来放置的更多的进程，这样在进行读写的时候就能够处理其他的进程，从而提高处理器的利用

**实存储器**

由于一个进程只能在内存中执行，因此这个存储器称为实存储器

**虚存**

比内存更大的存储器称为虚拟内存，虚存支持更有效的多道程序设计

在虚拟内存中，在任何时刻任何一个进程只有一部分位于内存中，可以在内存中保留更多的进程，由于没有用到的块不需要换入换出内存，因而节省了时间，当操作系统读取一块的时候必须把另一块换出，如果一块正好在将要用到之前换出，操作系统就不得不很快的把它取回来

**系统抖动：**

系统抖动就是处理器的大部分时间都用于交换块，而不是执行指令，所以要避免过多的系统抖动发生

**局部性原理：**

局部性原理描述了一个进程中程序和数据的引用的集簇倾向，假设在一个很短的时间内需要进程的一部分块是合理的，同时还可以猜测将可能访问的块，从而避免系统抖动

---

### 段页式
在段页式系统中，用户地址被划分成许多段。每个段被依次划分成大小相同的页，页的长度等于内存中页框的大小。如果某一段的长度  小于一页，则该段只占据一页。逻辑地址依然是由段号和偏移量组成的；段偏移量可以看做是指定段中的一个页号和页偏移量
### 保护和共享
分段有助于实现保护与共享机制。由于每个段包括一个长度和一个基地址，因此程序不会轻易的访问超出该段的内存单元。为实现共享，一个段可以在多个进程中被引用。在分页系统中也可以得到同样的机制。但是此种情况下程序的页结构和数据对程序员是不可见的，使得共享和保护的要求难以说明。
## 调度
### 调度的类型
长程调度|决定加入执行的进程池中
--:|:--
中程调度|决定加入部分或全部在内存中的进程集合中
短程调度|决定哪一个可执行的进程将被处理器执行
I/O调度|决定哪一个进程的I/O请求将被可用的I/O设备处理
长程调度，它决定是否把进程添加到当前活跃的进程集合中。中程调度是交换的一部分，它决定是否把进程添加到那些至少部分在内存中并且可以被执行的进程集合中去。短程调度真正决定下一次执行哪一个就绪进程。

**长程调度：**

长程调度决定哪一个程序可以进入系统中处理，它控制着系统并发度。一旦允许进入，一个作业或者用户程序就成为了一个进程，并被添加到被短程调度使用的队列中等待调动

在批处理系统或者操作系统的批处理中，新提交的作业被发送到磁盘，并保存在一个批处理队列中。在长程调度程序运行的时候，从队列中创建相应的进程。

调动程序需要决定什么时候操作系统能够接纳一个或者多个进程；同时，调度程序必须决定哪个作业或者哪些作业，将会变成进程。

创建的进程越多，每个进程可以执行的时间所占百分比就越小。当一个作业被终止的时候，调度程序可以决定增加一个或者多个新作业。此外，如果处理器空闲的时间超过了一定的阈值，也会启用长程调度程序。

**短程调度**

考虑执行的频繁度，长程调度执行的频率相对较低，并且仅仅是粗略的决定是否接受新进程及接受哪一个。为进行交换决定，中程调度程序执行的稍微频繁了一些。短程调度程序，也叫分派程序，执行地最为频繁，并且精确地决定下一次执行哪一个进程。

**优先级的使用**

在许多系统中，每个进程都被指定一个优先级，调度程序总是选择优先级高的进程。

纯粹的优先级方案会产生一个问题，低优先级的进程可能会长期处于饥饿状态。如果一直有高优先级的就绪程序，就会发生这种情况。一个进程的优先级应该随着时间或执行历史而变化。

[Boot Loader](https://baike.baidu.com/item/Boot%20Loader/10958293?fr=aladdin)